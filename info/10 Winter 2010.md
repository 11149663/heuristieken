# Programmeertheorie<br><small>a.k.a. Heuristieken</small>

## Studiewijzer, lente 2020
Deze cursus is de afsluiting van de Minor Programmeren. 
Na vele maanden ervaring opdoen met programmeren in Python, met object-oriëntatie en met problem solving, komt hier alles samen. 
Gegeven is een "onoplosbaar" probleem, waarvoor met behulp van klassieke AI-technieken toch nog heel goede oplossingen berekend kunnen worden. 
De problemen, "cases", komen uit allerlei vakgebieden en zijn vaak zeer realistische benaderingen van problemen uit de echte wereld.


## Docenten
Je docenten zijn Jelle van Assema en Wouter Vrielink, en Martijn Stegeman (coördinator).
De assistenten zijn Jasper den Duijf, Julien Fer, Okke van Eck en Quinte van der Post.


## Voorkennis
Programmeren 1 en Programmeren 2 moet je helemaal gehaald hebben vóór je deze cursus start. 
Daarnaast moet je één of meerdere programmeercursussen van de Minor Programmeren of daarbuiten hebben gehaald. 
Eventuele alternatieven worden per geval beoordeeld door de docent. 
Neem contact op als je niet aan bovenstaande basiseisen voldoet.


## Verwachtingen
Om de cursus tot een goed einde te brengen, verwachten we dat je:

1. alle onderdelen van de cursus afrondt in samenwerking met twee andere teamleden,
2. een case "oplost" met behulp van de in de cursus behandelde heuristische algoritmen,
3. met je teamgenoten samenwerkt aan de oplossingen via git,
4. de voortgang en inzichten uitlegt bij twee tussentijdse presentaties,
5. advies inwint bij je assistent tijdens de vier tussentijdse update-sessies,
6. regelmatig vragen stelt aan de assistenten en docenten,
7. actief deelneemt aan onderlinge code reviews bij de eindbeoordeling,
8. een zorgvuldig opgebouwd eindproduct inlevert, en
9. een eindpresentatie geeft in de week van 22 t/m 26 januari en alle andere eindpresentaties bijwoont.


## Cases
Voor deze editie van het vak kun je kiezen uit de volgende cases:

- [Amstelhaege](/cases/amstelhaege)
- [Chips & Circuits](/cases/chips-circuits)
- [Protein Pow(d)er](/cases/protein-pow-d-er)
- [RailNL](/cases/railnl)
- [Rush Hour](/cases/rush-hour)
- [SmartGrid](/cases/smartgrid)

Na het kiezen van een case kun je je team [registreren](/register).


## Eindcijfer
Het eindcijfer voor het vak Programmeertheorie bestaat uit drie onderdelen; exploratie van de case, uitleg van inzicht, en het eindproduct.
De drie cijfers worden gelijk gewogen, dus wegen ieder voor één derde mee. 
Alle onderdelen worden becijferd op de schaal 0 tot en met 5. 
Er kunnen ook halve punten toegewezen worden.

Let op dat je aan bovenstaande verwachtingen moet voldoen om een eindcijfer te kunnen halen.


#### Exploratie van de case
*Leer de belangrijke concepten uit het vakgebied kennen en programmeer ze uit.*

5. Creatieve exploratie en toepassing van aangeboden en niet aangeboden principes uit het vakgebied
4. Uitgebreide exploratie en toepassing op de case van de aangeboden principes uit het vakgebied
3. Exploratie en toepassing op de case van diverse principes uit het vakgebied
2. Toepassing op de case van enkele principes uit het vakgebied
1. Implementatie van een algoritme dat een oplossing zou kunnen genereren
{: start="5" reversed="reversed"}

Tijdens het vak zal je wekelijks een verplichte afspraak hebben met je eigen assistent (TA). 
Deze TA zal je niet alleen helpen met technische aspecten van het vak, maar zal ook iedere week notities maken over de vooruitgang van jouw team binnen het vak. 
Aan de hand van de gemaakte aantekeningen zal de TA samen met jouw team aan het einde van het vak een korte motivatie schrijven voor een cijfer. 
Deze motivatie en het cijfer worden vervolgens onafhankelijk beoordeeld en geverifieerd tijdens de eindpresentaties.  
**Je hoeft hiervoor niets extra's te doen of in te leveren.**


#### Uitleg van inzicht
*Presenteer en documenteer wat je hebt geleerd.*

5. Verregaande uitleg en analyse van de case en relatering tot het vakgebied van heuristieken
4. Samenhangende uitleg en analyse aan de hand van vakconcepten, implementatie en resultaten
3. Case en uitwerking nauwgezet uitgelegd aan de hand van de belangrijke aspecten uit het vak
2. Enkele belangrijke maar losse aspecten van het gedane werk nauwgezet uitgelegd
1. Opsomming van het gedane werk zonder duidelijke uitleg
{: start="5" reversed="reversed"}

Aan het einde van het vak presenteer je met je hele groepje over de case waar je aan gewerkt hebt. 
Deze presentatie duurt hooguit 10 minuten. 
Dit is erg krap, dus oefen de presentatie vooral een paar keer! 
Na de presentatie is er ruimte voor vragen (+/- 5 min).

Het is de bedoeling dat de presentatie een inleiding, uitleg over de oplossingsruimte, een beschrijving van gebruikte methoden, resultaten en de vergelijking hiervan, en uiteindelijk een discussie bevat. 
De slides zouden een bijdrage moeten leveren aan het verhaal van de sprekers. 
Gebruik van terminologie moet correct zijn en kijk ook uit voor het uitspreken van onwaarheden; maak goed onderscheid tussen wat een feit is en wat een vermoeden is; probeer altijd je claims te onderbouwen.


#### Eindproduct
*Maak je programma’s herbruikbaar en begrijpelijk voor de buitenwereld.*

5. Uitermate goed gestructureerde code en repository, met uitgebreide uitleg over implementatiedetails en de structuur van de code
4. Code is systematisch gestructureerd en documentatie wijst goed de weg in de code voor iemand die deze nog niet eerder heeft gelezen
3. Code is overwegend goed gestructureerd en de onderdelen worden afzonderlijk goed uitgelegd met commentaar en verdere documentatie
2. Code is globaal geordend in mapjes en files, en de code is grotendeels gedocumenteerd met commentaar op lokaal niveau
1. Code staat op GitHub, maar er is geen coherente documentatie of herkenbare structurering van de code
{: start="5" reversed="reversed"}

Gedurende het vak zal je als groep één GitHub repository gebruiken. 
Deze repository moet tenminste je eindproduct, een README, een equivalent aan een requirements.txt, en je presentatie bevatten. 
De link naar deze repository geef je aan het begin van het vak aan je TA. 
Voor een voorbeeldje van hoe je je GitHub repository op zou kunnen zetten vind je [hier](https://github.com/minprog/voorbeeld-repo).

Het is belangrijk dat de resultaten die je presenteert in je presentatie reproduceerbaar en correct zijn. 
De scripts moeten niet crashen en bug-vrij zijn. 
Het moet aan de hand van je README en/of voorbeeldcode duidelijk zijn hoe alles gereproduceerd zou kunnen worden. 
Lees ook even via [deze link](http://www.furnaceai.com/python/generating-a-requirements-txt-file-with-pip/) hoe je een requirements.txt maakt. 
Test de code ook even op een andere machine.

Let bij het schrijven van de code ook op dingen als modulariteit, abstractie, duplicate code, onnodige code, het gebruiken van een consistente stijl, en commentaar. 
Code zou makkelijk herbruikbaar moeten zijn voor soortgelijke projecten. 
Een gemakkelijke manier van het aanpakken van veel van deze punten is door gebruik te maken van het principe van [Object Oriented Programming](https://realpython.com/python3-object-oriented-programming/).


## Kalender

| Week |                                            | Onderdeel                                                      |
| ---: | ------------------------------------------ | -------------------------------------------------------------- |
|    1 | Interpretatie van de case                  | maandag 10 uur: Introcollege                                   |
|      |                                            | dinsdag 15 uur: Soorten problemen                              |
|      |                                            | woensdag 15 uur: Random oplossingen                            |
|    2 | Eerste resultaten van het programmeren     | maandag 15 uur: Depth-first en Breadth-first                   |
|      |                                            | dinsdag 15 uur: Hill climbing en meer                          |
|      |                                            | woensdag 15 uur: Toepassen van Heuristieken                    |
|    3 | Exploratie van de resultaten en verfijning |                                                                |
|    4 | Feedback en presentaties                   | deadline dinsdag: Repository, documentatie en code             |
|      |                                            | ergens van 24 t/m 26 mei, meerdere dagen: Eindpresentaties     |
|      |                                            | zelfde dag eindpresentaties: Inleveren presentatie als naslag  |


## Regels voor samenwerken
Bij dit vak is het de bedoeling om samen te werken aan alle producten die moeten worden opgeleverd. 
Het is belangrijk dat ieder teamlid een redelijk deel van het werk doet. 
Ook in dit geval is de frauderegeling van toepassing.

Fraude volgens de UvA: *"Het handelen of nalaten van een student waardoor een juist oordeel over zijn kennis, inzicht en vaardigheden geheel of gedeeltelijk onmogelijk wordt."*

Bij hergebruik van code uit blogposts, van Stack Overflow of dergelijk bronnen moet je een korte bronvermelding opnemen, direct in de code of als het om grotere delen gaat in de `README` van je project.
Let op dat de core algoritmen van het vak altijd zelf ontwikkeld moeten worden op basis van de omschrijvingen uit de colleges en de hulp van de docenten en assistenten.

Zie ook de [fraude- en plagiaatwebsite](http://www.uva.nl/plagiaat) van de universiteit.


## Herkansing
Als je het vak niet kunt afmaken in samenwerking met je team, dan zul je het vak bij de eerstvolgende mogelijkheid volledig opnieuw moeten doen (juni 2020). 
Je mag dan niet aan dezelfde case werken. 
Het is ook bij herkansing niet mogelijk om dit vak individueel te volgen.


## Dankbetuiging
Allergrootste dank gaat naar Daan van den Berg, die de cursus en veel van de cases tot wasdom heeft gebracht bij zijn versies van de cursus bij de Universiteit van Amsterdam. 
Daarnaast hebben vele assistenten, beoordelaars en studenten bijgedragen aan het bijschaven van de verschillende cases.

Heb je een toevoeging aan de cursus? Maak een issue aan op onze [GitHub-repository](https://github.com/minprog/heuristieken), of stuur een pull request.
